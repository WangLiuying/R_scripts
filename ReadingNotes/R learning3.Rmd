---
title: "R learning 3"
author: "Wang,Liuying"
date: "2016年10月9日"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Primitive Object Types
* **Vector**
    + integer: `integer()`
    + double: `double()` 
    + complex
    + character
    + logical
    + raw: A vector containing raw bytes.
* **Compound**
    + list
    + pairlist: `.Option` pair
    + S4: support modern object-oriented paradigms
    + environment: `.Globalenv new.env(ent=baseenv())`
* **Special**
    + any: used to mean that "any" type is OK, `setClass("Something",representation(data="ANY"))
    + NULL\
    + etc
* **R language**
    + symbol: `as.name(x) as.symbol(x) quote(x)`
    + promise: for implementing delayed loading of objects. `delayedAssign("v",c(x,y,z))`, v is a promise
    + language: `quote(function(x) {x+1})`
    + expression: An unevaluated R expression. It can be created with the `expression` function and later evaluated with the `eval` function.
```{r}
A <- expression(1+2)
eval(A)
```
* **Function** 
    + closure: An function not implemented inside the R system, including user-defined functions, most functions included with R, and most functions in R packages. 
    + special: An internal function whose arguments are not necessarily evaluated on call. For example `if [`
    + builtin: An internal function that evaluates its arguments. Say, `+ ^`
    + bytecode: Compiled R functions generated by the `compiler` package. `cmpfun(function(x)) {x^2}`
* **Internal**
    + char: A character vector is composed of `char` objects.
    + bytecode: a data type reseved for future byte-code compiler.
    + extenalptr: External pointer
    + weakref: Weak reference

###Vector
The `c` function *coerces* all of its arguments into a single type:
```{r}
v <- c(.295, .300, .250, .287, "zilch")
```
You can use the `c` function to recursively assemble a vector from other data structures using the `recursive=TRUE` option:
```{r}
v <- c(.295, .300, .250, list(.102, .200), recursive=T)
v
v <- c(.295, .300, .250, list(.102, .200))
typeof(v)
v
```
To creat a sequence:
```{r}
seq(from=5, to=25, by=5)
w <- 1:10
length(w)
length(w) <- 10
w
```
###matrix
We can give the rows(columns) names
```{r}
m <- matrix(data=1:12, nrow=4, ncol=3, dimnames=list(c("r1", "r2", "r3", "r4"),c("c1", "c2", "c3")))
```
`as.matrix()`
###Factor
To represent categorical values, by using factors.
```{r}
eye.colors <- c("brown", "blue", "blue", "green", "brown", "brown", "brown")
eye.colors <- factor(eye.colors)
eye.colors
levels(eye.colors)
eye.colors.integer.vector <- unclass(eye.colors)#turn it into integers
eye.colors.integer.vector
class(eye.colors.integer.vector)
class(eye.colors.integer.vector) <- "factor"
eye.colors.integer.vector
class(eye.colors.integer.vector)
```
You can use an ordered factor to represent the response of this survey.
```{r}
survey.results <- factor(
  c("Disagree", "Neutral", "Strongly Disagree", "Neutral", "Agree", "Strongly Agree", "Disagree", "Strongly Disagree", "Neutral", "Strongly Disagree", "Neutral", "Agree"),
  levels=c("Strongly Disagree", "Disagree", "Neutral", "Agree", "Strongly Agree"),
  ordered=T
)
survey.results
```

###Data frame
A data frame represents a table of data. Each column may be a different type(variables), but each row in the data frame must have the same length:
```{r}
top.bacon.searching.cities <- data.frame(
  city=c("Seattle", "Washington", "Chicago", "New York", "Portland", "St Louis", "Denver", "Boston", "Minneapolis", "Austin"), rank=c(100, 96, 94, 93, 93, 92, 90, 90, 89, 87)
)
top.bacon.searching.cities
###Formulas
```{r}
sample.formula <- as.formula(y~x1+x2+x3)
class(sample.formula);typeof(sample.formula)
```

* *Variable names*
* *Tilde(~)*：show the relationship between the response variables and the stimulus variables.
* *Plus sign(+)*: used to express a linear relationship between variables.
* *Zero(0)*: indicates that no intercept term should be included. `y~u+w+v+0`
* *Vertical bar(|)*: used to specify conditioning variables.
* *Identity function(I())*: used to indicate that the enclosed expression. 
For example: \
`a+b` means that both *a* and *b* should be included.\
`I(a+b)` means that *"a+b"* should be included.
* *Asterisk*: used to indicate interactions between variables.`y~u+v+w+I(u*w)`
* *Caret(^)*: used to indicate crossing to a specific degree. `y~(u+w)^2`
* *Function of variables*: `y~log(u)+sin(v)+w`
###Time Series
To create a time series object of class "ts", use the `ts` function.
`ts(data = NA, start = 1, end = numeric(), frequency = 1,
   deltat = 1, ts.eps = getOption("ts.eps"), class = , names = )`
`as.ts(x, ...)`
`is.ts(x)`
```{r}
ts(1:8, start=c(2008,2), frequency=4)
library(nutshell)
data(turkey.price.ts)
turkey.price.ts
start(turkey.price.ts)
end(turkey.price.ts)
frequency(turkey.price.ts)
deltat(turkey.price.ts)
```
###Shingles
A shingle is a generalization of a factor to a continuous variable. A shingle consist of a numeric vector and a set of intervals.
###Dates and Times
* *Date* represents dates but not times.
* *POSIXct* Stores dates and times as seconds since January 1, 1970, 12:00 a.m..
* *POSIXlt* Stores dates and times in separate vectors.
```{r}
date.I.started.writing <- as.Date("2/13/2009",format="%m/%d/%Y")
date.I.started.writing
today <- Sys.Date()
today
today-date.I.started.writing
```
###Connections
Connections are like file pointers in C or filehandles in Perl.\
To use connections, you create the connection, open the connection, use the connection, and close the connection.
```{r, }
consumption.connection <- gzfile(description="consumption.Rdata", open="r")
load(consumption.connection)
close(consumption.connection)
```
see the help file for `connection` for more information.
##Attributes
Objects in R can have many properties associated with them, called `attributes`. 
* class
* comment
* dim
* dimnames
* names
* row.names
* tsp: start time for an object. Useful for time series data.
* Levels: levels of a factor


