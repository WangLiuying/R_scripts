---
title: "试译稿"
author: "WISERCLUB"
date: "2016年12月20日"
output:
  pdf_document:
    includes:
      in_header: header.tex
    latex_engine: xelatex
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##列表

列表是一个广义的向量，它能够包含其他类型的对象，包括其它列表。

它非常地灵活有用。举例而言，用R拟合一个线性模型，其结果基本上就是一个列表，其中包含了线性回归的详细结果，例如，线性回归系数（数值向量），残差（数值向量），QR分解（包含一个矩阵和一些其它对象的列表），等等。

因为这些结果全都被打包到一个列表中了，所以我们可以非常便利地提取所需信息，而不需要每次调用不同的函数。

##创建一个列表

*list( )*，顾名思义，我们可以用它来创建一个列表。不同类型的对象可以被装进同一个列表。比如，以下代码创建了一个列表，列表中包含一个单元素的数值向量、一个两元素的逻辑向量和一个长度为3的字符向量：

```{r}
l0 <- list(1, c(TRUE, FALSE), c("a", "b", "c"))
l0
```

我们可以用具名参量来为列表中的每一个条目指定名称：

```{r}
l1 <- list(x = 1, y = c(TRUE, FALSE), z = c("a", "b", "c"))
l1
```

##从列表中取出一个元素

有许多种方法可以用来调取列表中的元素。最常用的方法是，使用美元符号*$*，通过元素的名称来提取列表元素的值。

```{r}
l1 <- list(x = 1, y = c(TRUE, FALSE), z = c("a", "b", "c"), m = NULL)
l1$x
l1$y
l1$m
```

注意，如果我们请求访问一个不存在的元素*m*，将会返回*NULL*。

或者，我们可以用两层方括号括住一个数字*n*，来提取列表中第*n*个元素的值。比如，我们可以通过以下方法取出列表*l1*中第二个元素的值：

```{r}
l1[[2]]
```

我们也可以用同样的符号来括住一个列表元素的名称，以取出相对应元素的值，类似于用美元符号：

```{r}
l1[["y"]]
```

使用双层方括号来提取列表中的值，这种方法更灵活，因为有时候，在计算之前，我们可能不知道哪一个元素是我们需要取出的：

```{r}
member <- "z" # 你可以随时改变你决定取出的元素
l1[[member]]
```

在这里，我们讲解了双方括号包含运行时才评估的、单元素字符向量的情况。但是，为什么我们要用双层括号呢？单层括号应该怎么用呢？

##构建子列表

许多场合下，我们需要从列表中取出多个元素。同时这些元素构成了原列表的一个子列表。

欲构建一个子列表，我们可以用单层方括号符号，就像提取向量和矩阵中元素一样。我们可以取出列表中的一些元素，把它们放到一个新的列表中。

这里方括号符号的用法同其在向量中的用法非常相似。我们可以用一个字符向量表示元素的名称、用数值向量表示元素的位置，或用逻辑向量指定选择标准，来取出列表元素。

```{r}
l1["x"]
l1[c("x", "y")]
l1[c(TRUE, FALSE, TRUE)]
```

总而言之，我们可以说，*[[*用来取出向量或列表中的一个元素，而*[*用来取出向量或列表的一个子集。创建向量的子集，会返回一个向量。相同地，创建一个列表的子集，会返回一个列表。